import marketDataService from '../services/marketDataService'
import kisService from '../services/kisService'
import { supabase } from '../services/supabaseService'

/**
 * ???????????????????????(???, ???, ??????)???????? ??????????? ?????????????
 * @param {Array} assets - ??? ??????????? ???
 * @param {Number} currentExchangeRate - ??? ??? ??? ??? (????? 1340)
 * @returns {Promise<{ updatedAssets: Array, nextExchangeRate: Number, marketData: Object }>}
 */
export const fetchAndUpdateAssetPrices = async (assets, currentExchangeRate = 1340) => {
    if (!assets || assets.length === 0) {
        return { updatedAssets: [], nextExchangeRate: currentExchangeRate, marketData: null }
    }

    try {
        let nextExchangeRate = currentExchangeRate
        let marketData = null

        // 1. Supabase ??? ???????????????? ???
        let dbPrices = {}
        if (supabase) {
            try {
                const { data } = await supabase.from('asset_prices').select('*')
                if (data && data.length > 0) {
                    data.forEach(row => {
                        dbPrices[row.symbol] = row
                    })
                }
            } catch (err) {
                console.warn('Failed to fetch from asset_prices cache, falling back to direct API', err)
            }
        }

        // ??? ?????? (DB ????????????? ???, ???????? ??? ????????)
        if (dbPrices['USD/KRW']) {
            nextExchangeRate = dbPrices['USD/KRW'].price
        }

        // DB ??????????? ??? ?????? ??? API???????? ??? ???
        const missingUsdStocks = []
        const missingKrwStocks = []
        let hasMissingCrypto = false

        assets.forEach(asset => {
            if (!dbPrices[asset.symbol]) {
                if ((asset.type === '???' || asset.type === 'ETF')) {
                    if (asset.currency === 'USD') missingUsdStocks.push(asset.symbol)
                    else if (asset.currency === 'KRW') missingKrwStocks.push(asset.symbol)
                } else if (asset.type === '????? || asset.type === '??????') {
                    hasMissingCrypto = true
                }
            }
        })

        // 2. ??? API Fallback (???????? ?????

        // ??? ??? ??? ??? ??? ???????? ??? ?????1?????
        if (hasMissingCrypto || !dbPrices['USD/KRW']) {
            try {
                marketData = await marketDataService.getAllMarketData()
                if (!dbPrices['USD/KRW'] && marketData?.currency?.usdKrw?.rate) {
                    nextExchangeRate = marketData.currency.usdKrw.rate
                }
            } catch (err) {
                console.warn('Failed to fetch fallback market data:', err)
            }
        }

        let fallbackUsdPrices = {}
        if (missingUsdStocks.length > 0) {
            fallbackUsdPrices = await marketDataService.getMultipleStockPrices(missingUsdStocks).catch(() => ({}))
        }

        let fallbackKrwPrices = {}
        if (missingKrwStocks.length > 0) {
            fallbackKrwPrices = await kisService.getMultiplePrices(missingKrwStocks).catch(() => ({}))
        }

        // 3. ??? ??????
        const updatedAssets = assets.map(asset => {
            let currentPrice = asset.currentPrice
            let dailyChangePercent = asset.dailyChangePercent || 0

            // 1???: DB ??? ?????            if (dbPrices[asset.symbol]) {
                currentPrice = dbPrices[asset.symbol].price
                dailyChangePercent = dbPrices[asset.symbol].change_percent
            }
            // 2???: ??? API Fallback ????????
            else if ((asset.type === '???' || asset.type === 'ETF') && asset.currency === 'USD' && fallbackUsdPrices[asset.symbol]) {
                currentPrice = fallbackUsdPrices[asset.symbol].price
                if (fallbackUsdPrices[asset.symbol].changePercent !== undefined) {
                    dailyChangePercent = fallbackUsdPrices[asset.symbol].changePercent
                }
            } else if ((asset.type === '???' || asset.type === 'ETF') && asset.currency === 'KRW' && fallbackKrwPrices[asset.symbol]) {
                currentPrice = fallbackKrwPrices[asset.symbol].price
                dailyChangePercent = fallbackKrwPrices[asset.symbol].changePercent || 0
            } else if (asset.symbol === 'BTC' && marketData.crypto?.bitcoin) {
                currentPrice = marketData.crypto.bitcoin.price
                dailyChangePercent = marketData.crypto.bitcoin.change24h || 0
            } else if (asset.symbol === 'ETH' && marketData.crypto?.ethereum) {
                currentPrice = marketData.crypto.ethereum.price
                dailyChangePercent = marketData.crypto.ethereum.change24h || 0
            } else if (asset.symbol === 'BNB' && marketData.crypto?.binancecoin) {
                currentPrice = marketData.crypto.binancecoin.price
                dailyChangePercent = marketData.crypto.binancecoin.change24h || 0
            } else if (asset.symbol === 'SOL' && marketData.crypto?.solana) {
                currentPrice = marketData.crypto.solana.price
                dailyChangePercent = marketData.crypto.solana.change24h || 0
            }

            const totalValue = asset.quantity * currentPrice
            const profit = totalValue - (asset.quantity * asset.avgPrice)
            const profitPercent = asset.avgPrice > 0 ? ((currentPrice - asset.avgPrice) / asset.avgPrice) * 100 : 0

            return {
                ...asset,
                currentPrice,
                totalValue,
                profit,
                profitPercent,
                dailyChangePercent
            }
        })

        return { updatedAssets, nextExchangeRate, marketData }
    } catch (error) {
        console.error('Failed to update asset prices:', error)
        throw error
    }
}
